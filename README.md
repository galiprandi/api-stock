# ğŸ“¦ API Stock â€“ Curso de Backend en TypeScript

Este es un curso prÃ¡ctico y progresivo diseÃ±ado para personas con conocimientos bÃ¡sicos de JavaScript y TypeScript que quieren aprender a construir un backend moderno con tecnologÃ­as actuales. A diferencia de otros cursos, aquÃ­ trabajarÃ¡s en un proyecto real desde el primer dÃ­a, evolucionando tu propio repositorio en GitHub a medida que avanzas.

## ğŸ¯ Objetivo del Curso

El objetivo es que, al finalizar, tengas una API funcional y escalable en tu GitHub, construida con buenas prÃ¡cticas y herramientas profesionales. AprenderÃ¡s desde los fundamentos hasta tÃ©cnicas avanzadas, ganando experiencia en un entorno similar al de un equipo de desarrollo real.

Este curso no solo te enseÃ±a a programar, sino que tambiÃ©n te prepara para enfrentar desafÃ­os comunes en el desarrollo backend, con un enfoque en depuraciÃ³n, pruebas automatizadas y uso de herramientas modernas.

## ğŸ‘¤ Â¿A quiÃ©n va dirigido?

- Personas que ya hicieron cursos introductorios de JavaScript/TypeScript y quieren dar el siguiente paso en backend.
- Desarrolladores que buscan experiencia prÃ¡ctica con un proyecto real.
- Estudiantes o autodidactas que quieran fortalecer su portafolio en GitHub.
- Quienes quieran aprender herramientas modernas como Prisma, GitHub Copilot y Zod aplicadas a un backend real.

No es un curso para **absolutos principiantes** en programaciÃ³n. Se asume que entendÃ©s los fundamentos de JavaScript y TypeScript, pero no necesitÃ¡s experiencia profesional en backend.

## ğŸ› ï¸ TecnologÃ­as y herramientas

Durante el curso, trabajarÃ¡s con un stack moderno que simula lo que se usa en la industria:\

âœ… **TypeScript**: CÃ³digo tipado para mayor seguridad y escalabilidad.\
âœ… **Express v5**: Framework rÃ¡pido y flexible para APIs REST.\
âœ… **Prisma ORM**: Interfaz moderna para bases de datos SQL.\
âœ… **PostgreSQL**: Base de datos robusta y estÃ¡ndar en la industria.\
âœ… **Vitest + Supertest**: Pruebas automatizadas con TDD.\
âœ… **Zod** â€“ Validaciones de datos seguras y declarativas.\
âœ… **GitHub Copilot + ChatGPT**: Aprendizaje asistido con IA.\
âœ… **GitHub Actions**: _(opcional)_ AutomatizaciÃ³n de pruebas y despliegue.\
âœ… **Docker + Railway**: _(opcional)_ Entornos de desarrollo y producciÃ³n reales.

## ğŸš€ Â¿QuÃ© aprenderÃ¡s?

âœ”ï¸ Configurar un backend profesional desde cero.\
âœ”ï¸ Crear endpoints REST con buenas prÃ¡cticas.\
âœ”ï¸ Manejar errores y validaciones avanzadas.\
âœ”ï¸ Conectar y gestionar bases de datos SQL con Prisma.\
âœ”ï¸ Aplicar TDD con pruebas automatizadas.\
âœ”ï¸ Implementar autenticaciÃ³n y autorizaciÃ³n con JWT.\
âœ”ï¸ Estructurar cÃ³digo de forma escalable con una arquitectura en capas.\
âœ”ï¸ Optimizar la API con paginaciÃ³n, filtros y consultas eficientes.\
âœ”ï¸ Desplegar la API en producciÃ³n _(opcional, con pasos extra)_.

## ğŸ“Œ MetodologÃ­a y progresiÃ³n

Este curso tiene un enfoque prÃ¡ctico y progresivo:

1. **Inicio guiado** â€“ Al principio, cada paso estÃ¡ detallado lÃ­nea por lÃ­nea.
2. **Menos guÃ­a, mÃ¡s autonomÃ­a** â€“ Luego, se dan requisitos y tests, dejando que el estudiante implemente.
3. **Uso de herramientas como GitHub Copilot** â€“ Para fomentar la resoluciÃ³n de problemas de forma autÃ³noma.
4. **ValidaciÃ³n con pruebas** â€“ Todo el cÃ³digo debe pasar tests para considerarse correcto.
5. **Pasos opcionales** â€“ Funcionalidades extra para quienes quieran profundizar mÃ¡s.

## ğŸŒ Comunidad y soporte

El curso fomenta el aprendizaje colaborativo dentro de GitHub, usando:

ğŸ“Œ **GitHub Discussions** â€“ Espacio para dudas y debates.\
ğŸ“Œ **Issues** â€“ Para reportar errores o sugerir mejoras.\
ğŸ“Œ **Pull Requests** â€“ Para desafÃ­os opcionales y contribuciones.

## ğŸ’¡ Â¿Por quÃ© este curso?

A diferencia de otros cursos en espaÃ±ol que se quedan en teorÃ­a o ejemplos bÃ¡sicos, este curso:

âœ… Te da un proyecto real que podÃ©s mostrar en GitHub.\
âœ… Usa herramientas actuales y prÃ¡cticas reales de la industria.\
âœ… Te entrena en depuraciÃ³n y pruebas automatizadas.\
âœ… No te deja todo servido: progresivamente te hace pensar y resolver problemas.

Si querÃ©s aprender backend de verdad, no solo copiar cÃ³digo, este curso es para vos. ğŸš€

## ğŸ¤ Contribuciones

Si querÃ©s mejorar este curso, podÃ©s contribuir de varias formas:

- Reportando errores o mejoras en la secciÃ³n de Issues.
- Proponiendo cambios mediante Pull Requests.
- Compartiendo el curso con otros desarrolladores.

Todas las sugerencias y mejoras son bienvenidas. ğŸš€

## ğŸ‘¤ Autor

Este curso fue creado por [GermÃ¡n Aliprandi](https://www.linkedin.com/in/galiprandi). Si tenÃ©s preguntas o sugerencias, no dudes en contactarme o abrir una discusiÃ³n en GitHub.

## ğŸ“œ Licencia

Este proyecto estÃ¡ bajo la Licencia MIT, lo que significa que podÃ©s usar, modificar y distribuir el cÃ³digo con total libertad, siempre que incluyas la licencia original.

## Paso 1: Fork del repositorio [api-stock](https://github.com/galiprandi/api-stock)

> ğŸ“š Â¿Que es un fork? Un fork es una copia de un repositorio que se crea en tu cuenta de GitHub. Permite que puedas hacer cambios en el proyecto original sin afectar el repositorio principal. Los forks son Ãºtiles cuando deseas contribuir a un proyecto de cÃ³digo abierto, ya que puedes trabajar en tus propias modificaciones y luego proponer que se integren en el proyecto original mediante un pull request.

### Verificar que tengas una cuenta en GitHub

Si no tienes una cuenta en GitHub, [regÃ­strate en GitHub](https://github.com/join).
Si ya tienes una cuenta, asegÃºrate de haber iniciado sesiÃ³n.

### Instalar y configurar Git y GitHub CLI

Sigue las instrucciones en la [pÃ¡gina oficial de Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).
Instalar GitHub CLI (gh):

Sigue las instrucciones en la [pÃ¡gina oficial de GitHub CLI](https://cli.github.com/).
Configurar Git:

Configura tu nombre de usuario y correo electrÃ³nico:

```bash
git config --global user.name "Tu Nombre"
git config --global user.email "tu-email@example.com"
```

### Hacer el fork, clonar el repo y abrirlo en VSCode

En tu navegador, ve al repositorio original: https://github.com/galiprandi/api-stock.
Haz clic en el botÃ³n "Fork" en la esquina superior derecha y selecciona tu cuenta.
Clonar el repositorio:

En tu terminal, clona el repositorio forkeado:
Cambia tu-usuario por tu nombre de usuario de GitHub.
Abrir el proyecto en VSCode:

Navega al directorio del proyecto clonado:
Abre el proyecto en VSCode:

Con estos pasos, habrÃ¡s completado la configuraciÃ³n inicial y estarÃ¡s listo para comenzar a trabajar en el proyecto.

## Paso 2: Configuremos nuestro proyecto

Primero, necesitamos inicializar TypeScript en nuestro proyecto. Abre tu terminal y ejecuta el siguiente comando:

```bash
npm install -D typescript # Instalar TypeScript como dependencia de desarrollo
npx tsc --init # Inicializar un archivo de configuraciÃ³n de TypeScript
```

Esto crearÃ¡ un archivo `tsconfig.json` en tu proyecto. A continuaciÃ³n, te muestro un ejemplo de un archivo `tsconfig.json` optimizado para una aplicaciÃ³n Node.js, reemplaza el contenido de tu archivo `tsconfig.json` con el siguiente cÃ³digo, te recomendamos que habras el proyecto en VSCode para hacerlo mÃ¡s fÃ¡cil:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "resolveJsonModule": true,
    "sourceMap": true
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules"]
}
```

Este archivo de configuraciÃ³n establece varias opciones importantes para un proyecto Node.js, como el objetivo de compilaciÃ³n (target), el sistema de mÃ³dulos (module), y los directorios de salida y raÃ­z (outDir y rootDir).

> ğŸ“š Para mÃ¡s detalles sobre las opciones de configuraciÃ³n de TypeScript, te recomiendo leer la [cheat sheet de tsconfig](https://www.totaltypescript.com/tsconfig-cheat-sheet).

### Scripts del package.json

Ahora, vamos a agregar algunos scripts Ãºtiles en nuestro archivo `package.json`. Abre el archivo `package.json` y agrega los siguientes scripts en la secciÃ³n "scripts":

```json
{
  "scripts": {
    "dev": "tsx watch --env-file=.env src/index.ts",
    "build": "tsc",
    "start": "node --env-file=.env dist/index.js"
  }
}
```

- `npm run dev`: Este script utiliza tsx para ejecutar tu aplicaciÃ³n en modo de desarrollo, permitiendo recargas automÃ¡ticas cuando cambias el cÃ³digo.

- `npm run build`: Este script compila tu cÃ³digo TypeScript en JavaScript, colocando los archivos compilados en el directorio dist.

- `npm run start`: Este script ejecuta la versiÃ³n compilada de tu aplicaciÃ³n desde el directorio dist.

Con estos scripts, estarÃ¡s listo para desarrollar, compilar y ejecutar tu aplicaciÃ³n Node.js con TypeScript.

### Instalemos dependencias de desarrollo

Para poder ejecutar nuestra aplicaciÃ³n en modo de desarrollo, necesitamos instalar tsx y @types/node. Ejecuta el siguiente comando en tu terminal:

> ğŸ“š Â¿QuÃ© es tsx? tsx es una herramienta que permite ejecutar TypeScript en Node.js con soporte para hot-reloading, lo que significa que la aplicaciÃ³n se reinicia automÃ¡ticamente cuando se detectan cambios en el cÃ³digo fuente.

> ğŸ“š Â¿Cuales son las diferencias entre dependencias de desarrollo y de producciÃ³n? Las dependencias de desarrollo son aquellas que solo se necesitan durante el proceso de desarrollo, como herramientas de prueba y compiladores. Las dependencias de producciÃ³n son aquellas que se necesitan para que la aplicaciÃ³n funcione en un entorno de producciÃ³n, como bibliotecas y frameworks necesarios para la ejecuciÃ³n del cÃ³digo.

```bash
npm install -D tsx @types/node
```

### GestiÃ³n de variables de entorno

> ğŸ“š Â¿QuÃ© son las variables de entorno? Las variables de entorno son valores dinÃ¡micos que pueden afectar el comportamiento de un programa. Se utilizan para configurar la aplicaciÃ³n en diferentes entornos, como desarrollo, pruebas y producciÃ³n.

Antes de crear el archivo `.env` que contrendrÃ¡ informaciÃ³n sensible, debemos crear un archivo `.gitignore` en la raÃ­z de tu proyecto y agregues las siguientes lÃ­neas:

```env
.env
node_modules
dist
```

âš ï¸ IMPORTANTE: Esto evitarÃ¡ que el archivo .env, con las variables de entorno sensibles, se suba al repositorio.

Para gestionar las variables de entorno en nuestro proyecto, vamos a crear un archivo `.env` en la raÃ­z de nuestro proyecto. Este archivo contendrÃ¡ las variables de entorno necesarias para configurar nuestra aplicaciÃ³n.

Crea un archivo `.env` en la raÃ­z de tu proyecto y agrega las siguientes variables de entorno:

```env
PORT=3000
```

Para centrar la gestiÃ³n de las variables de entorno en un solo lugar, vamos a crear un archivo de configuraciÃ³n `src/config.ts` que cargarÃ¡ las variables de entorno y las exportarÃ¡ para su uso en la aplicaciÃ³n.

Crea un archivo `src/config.ts` y agrega el siguiente cÃ³digo:

```typescript
export const config = {
  ENV: process.env.NODE_ENV || "development",
  PORT: process.env.PORT || 3000,
};
```

### Hello World!

Para verificar que todo estÃ¡ configurado correctamente, vamos a crear un simple "Hello World!" en la consola. Crea un archivo `src/index.ts` con el siguiente contenido:

```typescript
console.log("Hello, World!");
```

Ahora, ejecuta el siguiente comando en tu terminal:

```bash
npm run dev
```

DeberÃ­as ver el mensaje "Hello, World!" impreso en la consola. Si ves este mensaje, Â¡tu configuraciÃ³n de TypeScript estÃ¡ lista y funcionando! Ahora, puedes avanzar al siguiente paso.

```bash
# Salida esperada
> npx tsx watch --env-file=.env src/index.ts

Hello, World!
```

### Probando el hot-reloading

Para probar el hot-reloading, modifica el mensaje en `src/index.ts` por "Hello, TypeScript!" y guarda el archivo. DeberÃ­as ver que el servidor se reinicia automÃ¡ticamente y muestra el nuevo mensaje en la consola.

> ğŸ“š Â¿QuÃ© es hot-reloading? Hot-reloading es una tÃ©cnica que permite recargar automÃ¡ticamente la aplicaciÃ³n cuando se detectan cambios en el cÃ³digo fuente. Es una caracterÃ­stica muy Ãºtil para el desarrollo de aplicaciones, ya que permite ver los cambios en tiempo real sin tener que reiniciar manualmente el servidor.

```bash
# Salida esperada
Hello, TypeScript!
```

Â¡Excelente! Has configurado correctamente tu proyecto con TypeScript y tsx. Ahora, puedes avanzar al siguiente paso para configurar un servidor Express.

## Paso 3: ConfiguraciÃ³n del Servidor Express y primer endpoint

En este paso, vamos a instalar Express y CORS, y crearemos un endpoint /api/health-check que devolverÃ¡ `status: "ready"`.

> ğŸ“š Â¿QuÃ© funciÃ³n tiene este endpoint? Este tipo de endpoints son comunes en las aplicaciones web y sirven para verificar si el servidor estÃ¡ en funcionamiento y listo para recibir solicitudes. Proporciona una forma sencilla de comprobar el estado del servidor y la conexiÃ³n a la base de datos.

### Instalar Dependencias

Ejecuta el siguiente comando en tu terminal para instalar Express y CORS:

```bash
# Instalar Express y CORS
npm install "express@>=5.0.0" cors 
# Instalar tipos de TypeScript para Express y CORS
npm install -D @types/express @types/cors
```

### Configurar el Servidor

Crea el archivo `src/libs/server.ts` y agrega el siguiente cÃ³digo:

```typescript
import cors from "cors";
import express from "express";

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Rutas
app.get("/api/health-check", (_req, res) => {
  res.json({ status: "ready", uptime: process.uptime() });
});

// Exportar el servidor para usarlo en index.ts
export { app };
```

> ğŸ“š Â¿QuÃ© es un middleware? En Express, un middleware es una funciÃ³n que tiene acceso al objeto de solicitud (req), al objeto de respuesta (res) y a la siguiente funciÃ³n de middleware en el ciclo de solicitud-respuesta. Los middlewares se utilizan para realizar tareas como el registro de solicitudes, la validaciÃ³n de datos, la autenticaciÃ³n de usuarios, etc.

### Inicializar el Servidor

Edita `src/index.ts` para importar e iniciar el servidor:

```typescript
import { config } from "./config";
import { app } from "./libs/server";

const { PORT } = config;

app.listen(PORT, () => {
  console.log(
    `ğŸš€ Server is up and running! Access it at: http://localhost:${PORT}/api/health-check`,
  );
});
```

### Probar el Servidor

Ejecuta el siguiente comando:

```bash
npm run dev
```

Luego, abre tu navegador o usa curl para probar el endpoint:

```bash
curl http://localhost:3000/api/health-check
```

DeberÃ­as recibir esta respuesta:

```json
{ "status": "ready", "uptime": 0.123 }
```

> ğŸ“š Â¿QuÃ© es curl? curl es una herramienta de lÃ­nea de comandos que permite transferir datos con URL sintÃ¡cticas. Es una herramienta muy practica para realizar solicitudes HTTP desde la terminal.

### Criterios de AceptaciÃ³n del Paso 3

- [ ] DeberÃ¡s instalar Express y CORS en tu proyecto.
- [ ] DeberÃ¡s crear un servidor Express en el archivo `src/libs/server.ts`.
- [ ] El servidor deberÃ¡ tener un endpoint GET `/api/health-check` que devuelva `{ status: 'ready' }`.
- [ ] DeberÃ¡s inicializar el servidor en el archivo `src/index.ts` y escuchar en el puerto 3000.
- [ ] DeberÃ¡s probar el servidor y verificar que el endpoint `/api/health-check` responda correctamente.

### ğŸ‰ Â¡Felicitaciones!

Has creado tu primer endpoint en Express. Ahora, puedes avanzar al siguiente paso para implementar mÃ¡s funcionalidades en tu API.

## Paso 4: Agregar Pruebas Unitarias

> ğŸ“š Â¿QuÃ© son las pruebas unitarias? Las pruebas unitarias son pruebas automatizadas que verifican que una unidad de cÃ³digo (como una funciÃ³n o un mÃ³dulo) funcione correctamente. Estas pruebas se centran en probar partes especÃ­ficas del cÃ³digo para garantizar que se comporten como se espera.

En este paso, agregaremos pruebas automatizadas para verificar que el endpoint /api/health-check responde correctamente.

### Instalar Dependencias necesarias

Primero, necesitamos instalar Vitest y Supertest para realizar pruebas automatizadas. Ejecuta el siguiente comando en tu terminal:

```bash
npm install -D vitest supertest @types/supertest
```

### Crear el Archivo de Pruebas

> ğŸ’¡ Todos los archivos de pruebas unitarias estarÃ¡n alojados en la carpeta `src/tests/` lo que facilita su organizaciÃ³n y mantenimiento.

Crea el archivo `src/tests/health-check.get.test.ts` y agrega el siguiente cÃ³digo:

```typescript
import request from "supertest";
import { describe, expect, it } from "vitest";
import { app } from "../libs/server";

describe("GET /api/health-check", () => {
  it("should return { status: 'ready' }", async () => {
    const response = await request(app).get("/api/health-check");

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty("status", "ready");
  });
});
```

### Agregar el Script para lanzar las Pruebas

Agrega el siguiente script en la secciÃ³n "scripts" de tu archivo `package.json`:

```json
{
  "scripts": {
    "test": "vitest"
  }
}
```

### Ejecutar las Pruebas

Ejecuta el siguiente comando en tu terminal para ejecutar las pruebas:

```bash
npm test
```

DeberÃ­as ver una salida similar a esta:

```bash
 âœ“ src/tests/health-check.get.test.ts (1 test) 28ms
   âœ“ GET /api/health-check > should return { status: 'ready' }

 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  02:44:18
   Duration  208ms

 PASS  Waiting for file changes...
       press h to show help, press q to quit
```

Â¡Listo! Ahora tienes pruebas automatizadas para validar que el endpoint /api/health-check funciona correctamente. ğŸš€

### ğŸ‰ Â¡Felicitaciones!

En este punto, has configurado tu proyecto con TypeScript y Express, ademÃ¡s haz configurado tu primer endpoint y pruebas automatizadas. Â¡EstÃ¡s en camino de construir una API REST moderna para control de inventario!

Si aÃºn tienes ganas de explorar mÃ¡s en profundidad, puedes visitar los siguientes recursos:

- [Express.js](https://expressjs.com/en/guide/routing.html)
- [Pruebas con Vites](https://vitest.dev/guide)
- [Intercambio de recursos de origen cruzado (CORS)](https://developer.mozilla.org/es/docs/Web/HTTP/CORS)
- [Supertest](https://github.com/ladjs/supertest)
- [API REST](https://es.wikipedia.org/wiki/Transferencia_de_Estado_Representacional)

## Paso 5: Ruta /api/products

En este paso, vamos a implementar una ruta que devuelva una lista mockeada de productos. Esta ruta serÃ¡ accesible a travÃ©s de /api/products con el mÃ©todo GET y devolverÃ¡ una lista de productos en formato JSON.

### Crear un Mock de Productos

Crea un archivo `src/data/products.ts` y agrega el siguiente cÃ³digo:

```typescript
export const products = [
  {
    id: 1,
    title: "Laptop",
    brand: "Apple",
    category: "Electronics",
    price: 1299.99,
    stock: 10,
  },
  {
    id: 2,
    title: "Smartphone",
    brand: "Samsung",
    category: "Electronics",
    price: 899.99,
    stock: 20,
  },
  {
    id: 3,
    title: "Tablet",
    brand: "Amazon",
    category: "Electronics",
    price: 299.99,
    stock: 5,
  },
  {
    id: 4,
    title: "Smartwatch",
    brand: "Fitbit",
    category: "Electronics",
    price: 199.99,
    stock: 15,
  },
  {
    id: 5,
    title: "Headphones",
    brand: "Sony",
    category: "Electronics",
    price: 99.99,
    stock: 30,
  },
  {
    id: 6,
    title: "Backpack",
    brand: "North Face",
    category: "Fashion",
    price: 79.99,
    stock: 25,
  },
  {
    id: 7,
    title: "Sneakers",
    brand: "Nike",
    category: "Fashion",
    price: 129.99,
    stock: 40,
  },
  {
    id: 8,
    title: "T-shirt",
    brand: "Adidas",
    category: "Fashion",
    price: 29.99,
    stock: 50,
  },
  {
    id: 9,
    title: "Jeans",
    brand: "Levi's",
    category: "Fashion",
    price: 59.99,
    stock: 20,
  },
  {
    id: 10,
    title: "Sunglasses",
    brand: "Ray-Ban",
    category: "Fashion",
    price: 149.99,
    stock: 10,
  },
];
```

> ğŸ“š Â¿QuÃ© es un mock de datos? Un mock de datos es un conjunto de datos falsos o simulados que se utilizan para pruebas o desarrollo. En este caso, hemos creado un mock de productos que se utilizarÃ¡ para simular una base de datos de productos hasta que implementemos la integraciÃ³n con Prisma y PostgreSQL.

### Crear la Ruta /api/products

En este punto es importante que separemos las rutas en archivos diferentes para mantener nuestro cÃ³digo organizado y fÃ¡cil de mantener. Crea un archivo `src/routes/products.ts` y agrega el siguiente cÃ³digo:

```typescript
import { Router } from "express";
import { products } from "../data/products";

const router = Router();

router.get("/", (_req, res) => {
  res.json(products);
});

export { router as productsRouter };
```

### Agregar la Ruta en el Servidor

Importa y usa la ruta `/api/products` en tu servidor. Edita el archivo `src/libs/server.ts` para agregar la ruta de productos:

```typescript
import cors from "cors";
import express from "express";
import { productsRouter } from "../routes/products";

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Rutas
app.get("/api/health-check", (_req, res) => {
  res.json({ status: "ready", uptime: process.uptime() });
});

app.use("/api/products", productsRouter);

// Exportar el servidor para usarlo en index.ts
export { app };
```

### Probar la Ruta /api/products

Ejecuta tu servidor con `npm run dev` y luego abre tu navegador o usa curl para probar la ruta `/api/products`:

```bash
curl http://localhost:3000/api/products
```

DeberÃ­as recibir una respuesta con la lista de productos en formato JSON.

### Pruebas Automatizadas para /api/products

Agrega pruebas automatizadas para la ruta `/api/products`. Crea un archivo `src/tests/products.get.test.ts` y agrega el siguiente cÃ³digo:

```typescript
import request from "supertest";
import { describe, expect, it } from "vitest";
import { products } from "../data/products";
import { app } from "../libs/server";

// âš ï¸ Introducimos un error intencional en la prueba
describe("GET /api/products", () => {
  it("should return a list of products", async () => {
    const response = await request(app).get("/api/products");

    expect(response.status).toBe(200);
    expect(response.body).not.toEqual(products);
  });
});
```

> ğŸ“š Â¿QuÃ© es TDD? El Desarrollo Guiado por Pruebas (TDD) es una metodologÃ­a de desarrollo de software en la que las pruebas se escriben antes del cÃ³digo de producciÃ³n. El ciclo de TDD generalmente sigue estos pasos:
>
> 1. **Escribir una prueba que falle:** Crear una prueba automatizada para una nueva funcionalidad que aÃºn no estÃ¡ implementada.
> 2. **Escribir el cÃ³digo mÃ­nimo para pasar la prueba:** Implementar el cÃ³digo necesario para que la prueba pase.
> 3. **Refactorizar el cÃ³digo:** Mejorar el cÃ³digo asegurÃ¡ndose de que todas las pruebas sigan pasando.
>
> En este caso, hemos introducido un error intencional en la prueba para que falle. El siguiente paso es corregir el cÃ³digo para que la prueba pase.

### âš ï¸ Recuerda corregir la Prueba

Corrige la prueba en `src/tests/products.get.test.ts` para que pase correctamente. Lee atentamente el cÃ³digo de la prueba, ejecuta las pruebas y asegÃºrate de que pasen correctamente.

### ğŸ‰ Â¡Felicitaciones!

Haz avanzado mucho y ya tiene la estructura bÃ¡sica de tu API REST y los conocimientos necesarios para agregar nuevas rutas y funcionalidades. A partir de ahora las intrucciones serÃ¡n menos precisas y tendrÃ¡s que investigar y probar por tu cuenta. Las proximas tareas serÃ¡n mÃ¡s parecidas a requeriemientos de un cliente y tendrÃ¡s que implementarlos por tu cuenta, pero siempre especificaremos los criterios de aceptaciÃ³n que deberÃ¡s cumplir.

> ğŸ’¡ Recuerda apoyarte en las sugerencias de GitHub Copilot a partir de ahora, serÃ¡ tu compaÃ±ero y te facilitarÃ¡ el aprendizaje y las tareas repetitivas. Para mÃ¡s informaciÃ³n, consulta la [documentaciÃ³n oficial de GitHub Copilot](https://docs.github.com/en/copilot/quickstart?tool=visualstudio).

## Paso 6: Implementar un Endpoint para Crear Productos

En este paso, vamos a implementar un endpoint POST /api/products que permita crear un nuevo producto. El endpoint recibirÃ¡ los datos del producto en el cuerpo de la solicitud y devolverÃ¡ el producto creado con un ID Ãºnico.

Los pasos a seguir son los siguientes:

1. Crear la ruta POST /api/products en el archivo `src/routes/products.ts`.
2. Recuperar del body de la solicitud los datos del producto a crear.
3. Generar un ID Ãºnico para el nuevo producto. Por ahora puedes usar la longitud del array + 1 como ID.
4. Agregar el nuevo producto al array de productos usando el mÃ©todo push.
5. Devolver el producto creado con el cÃ³digo de estado 201 (Created).
6. Verifica que el GET /api/products devuelva las lista de productos con el nuevo producto creado.
7. Agregar pruebas automatizadas para el endpoint POST /api/products.

Comencemos creando primero las pruebas unitarias, crea el archivo `src/tests/products.post.test.ts` y agrega el siguiente cÃ³digo:

```typescript
import request from "supertest";
import { describe, expect, it } from "vitest";
import { products } from "../data/products";
import { app } from "../libs/server";

describe("POST /api/products", () => {
  it("should create a new product", async () => {
    const totlasProducts = products.length;
    const newProduct = {
      title: "Smart Speaker",
      brand: "Google",
      category: "Electronics",
      price: 99.99,
      stock: 15,
    };

    const response = await request(app)
      .post("/api/products")
      .send(newProduct);

    expect(response.status).toBe(201);
    expect(response.body.id).toBe(totlasProducts + 1);
    expect(response.body).toMatchObject(newProduct);
  });
});
```

Una vez que hayan implementado el endpoint POST /api/products y las pruebas unitarias unitarias pasen correctamente, prueba manualmente crea un nuevo producto usando el siguiente curl:

```bash
# Curl para crear un nuevo producto
curl -X POST http://localhost:3000/api/products -H "Content-Type: application/json" -d '{"title": "Smart Speaker", "brand": "Google", "category": "Electronics", "price": 99.99, "stock": 15}'
```

### Criterios de AceptaciÃ³n del Paso 6

- [ ] DeberÃ¡s implementar el endpoint POST /api/products en el archivo src/routes/products.ts.
- [ ] El endpoint deberÃ¡ recibir los datos del producto a crear en el cuerpo de la solicitud.
- [ ] El endpoint deberÃ¡ devolver el producto creado con un ID Ãºnico y el cÃ³digo de estado 201 (Created).
- [ ] El producto creado deberÃ¡ ser agregado al array de productos.
- [ ] El endpoint GET /api/products deberÃ¡ devolver la lista de productos con el nuevo producto creado.
- [ ] DeberÃ¡s agregar pruebas automatizadas para el endpoint POST /api/products.

## Paso 7: Implementar un Endpoint para Actualizar Productos

> ğŸ“š Â¿QuÃ© significa CRUD? CRUD es un acrÃ³nimo que significa Crear, Leer, Actualizar y Eliminar. Se utiliza para describir las cuatro operaciones bÃ¡sicas que se pueden realizar en una base de datos o en una API REST.

En este paso, vamos a implementar un endpoint PUT /api/products/:id que permita actualizar un producto existente. El endpoint recibirÃ¡ el ID del producto a actualizar en la URL y los nuevos datos del producto en el cuerpo de la solicitud.

Los pasos a seguir son los siguientes:

1. Crear la ruta PUT /api/products/:id en el archivo `src/routes/products.ts`.
2. Recuperar el ID del producto a actualizar de los parÃ¡metros de la URL.
3. Recuperar los nuevos datos del producto del cuerpo de la solicitud.
4. Buscar el producto con el ID proporcionado en el array de productos.
5. Actualizar los datos del producto con los nuevos datos proporcionados.
6. Devolver el producto actualizado con el cÃ³digo de estado 200 (OK).
7. Verificar que el GET /api/products devuelva las lista de productos con el producto actualizado.
8. Agregar pruebas automatizadas para el endpoint PUT /api/products/:id.

Comencemos creando primero las pruebas unitarias, crea el archivo `src/tests/products.put.test.ts` y agrega el siguiente cÃ³digo:

```typescript
import request from "supertest";
import { describe, expect, it } from "vitest";
import { app } from "../libs/server";

describe("PUT /api/products/:id", () => {
  it("should update an existing product", async () => {
    const productId = 1;
    const updatedProduct = {
      title: "Updated Laptop",
      brand: "Apple",
      category: "Electronics",
      price: 1499.99,
      stock: 5,
    };

    const response = await request(app)
      .put(`/api/products/${productId}`)
      .send(updatedProduct);

    expect(response.status).toBe(200);
    expect(response.body).toMatchObject(updatedProduct);
  });

  it("should return 404 if product not found", async () => {
    const productId = "invalid-id";
    const updatedProduct = {
      title: "Updated Laptop",
      brand: "Apple",
      category: "Electronics",
      price: 1499.99,
      stock: 5,
    };

    const response = await request(app)
      .put(`/api/products/${productId}`)
      .send(updatedProduct);

    expect(response.status).toBe(404);
    expect(response.body).toMatchObject({ message: "Product not found" });
  });
});
```

Una vez que hayan implementado el endpoint PUT /api/products/:id y las pruebas unitarias unitarias pasen correctamente, prueba manualmente actualizando un producto usando el siguiente curl:

```bash
# Curl para actualizar un producto
curl -X PUT http://localhost:3000/api/products/1 -H "Content-Type: application/json" -d '{"title": "Updated Laptop", "brand": "Apple", "category": "Electronics", "price": 1499.99, "stock": 5}'
```

### Criterios de AceptaciÃ³n del Paso 7

- [ ] DeberÃ¡s implementar el endpoint PUT /api/products/:id en el archivo src/routes/products.ts.
- [ ] El endpoint deberÃ¡ recibir el ID del producto a actualizar en los parÃ¡metros de la URL.
- [ ] El endpoint deberÃ¡ recibir los nuevos datos del producto en el cuerpo de la solicitud.
- [ ] El producto actualizado deberÃ¡ ser devuelto con el cÃ³digo de estado 200 (OK).
- [ ] DeberÃ¡s agregar pruebas automatizadas para el endpoint PUT /api/products/:id.

## Paso 8: Implementar un Endpoint para Eliminar Productos

En este paso, vamos a implementar un endpoint DELETE /api/products/:id que permita eliminar un producto existente. El endpoint recibirÃ¡ el ID del producto a eliminar en la URL.

Los pasos a seguir son los siguientes:

1. Crear la ruta DELETE /api/products/:id en el archivo `src/routes/products.ts`.
2. Recuperar el ID del producto a eliminar de los parÃ¡metros de la URL.
3. Buscar el producto con el ID proporcionado en el array de productos.
4. Eliminar el producto del array de productos.
5. Devolver el producto eliminado con el cÃ³digo de estado 200 (OK).
6. Verificar que el GET /api/products devuelva las lista de productos sin el producto eliminado.
7. Agregar pruebas automatizadas para el endpoint DELETE /api/products/:id.

Comencemos creando primero las pruebas unitarias, crea el archivo `src/tests/products.delete.test.ts` y agrega el siguiente cÃ³digo:

```typescript
import request from "supertest";
import { describe, expect, it } from "vitest";
import { products } from "../data/products";
import { app } from "../libs/server";

describe("DELETE /api/products/:id", () => {
  it("should delete an existing product", async () => {
    const productId = 1;
    const response = await request(app).delete(`/api/products/${productId}`);

    expect(response.status).toBe(200);
    expect(response.body).toMatchObject({ message: "Product deleted" });
    expect(products.some(product => product.id === productId)).toBe(false);
  });

  it("should return 404 if product not found", async () => {
    const productId = "invalid-id";
    const response = await request(app).delete(`/api/products/${productId}`);

    expect(response.status).toBe(404);
    expect(response.body).toMatchObject({ message: "Product not found" });
  });
});
```

Una vez que hayan implementado el endpoint DELETE /api/products/:id y las pruebas unitarias unitarias pasen correctamente, prueba manualmente eliminando un producto usando el siguiente curl:

```bash
# Curl para eliminar un producto
curl -X DELETE http://localhost:3000/api/products/1
```

### Criterios de AceptaciÃ³n del Paso 8

- [ ] DeberÃ¡s implementar el endpoint DELETE /api/products/:id en el archivo src/routes/products.ts.
- [ ] El endpoint deberÃ¡ recibir el ID del producto a eliminar en los parÃ¡metros de la URL.
- [ ] El producto eliminado deberÃ¡ ser devuelto con el cÃ³digo de estado 200 (OK).
- [ ] El producto eliminado deberÃ¡ ser removido del array de productos.
- [ ] DeberÃ¡s agregar pruebas automatizadas para el endpoint DELETE /api/products/:id.

## Paso 9: IntroducciÃ³n a la Observabilidad y ConfiguraciÃ³n de Herramientas

> ğŸ“š Â¿QuÃ© es la observabilidad? La observabilidad es la capacidad de comprender y depurar un sistema complejo a travÃ©s de la recopilaciÃ³n y anÃ¡lisis de datos. En el contexto de las aplicaciones web, la observabilidad se refiere a la capacidad de monitorear y analizar el comportamiento de la aplicaciÃ³n en tiempo real.

En este paso, vamos a introducir los conceptos bÃ¡sicos de observabilidad y configurar herramientas para el monitoreo y logging de nuestra API. La observabilidad es crucial para entender el comportamiento de nuestra aplicaciÃ³n en producciÃ³n y detectar problemas antes de que afecten a los usuarios.

### InstalaciÃ³n de Pino Logger

[Pino](https://getpino.io) es una biblioteca de logging rÃ¡pida y eficiente para Node.js. Vamos a instalar y configurar Pino para registrar eventos y errores en nuestra API.

Ejecuta el siguiente comando en tu terminal para instalar Pino:

```bash
npm install pino pino-pretty pino-http
```

### ConfiguraciÃ³n de Pino Logger

Crea un archivo `src/libs/logger.ts` para configurar Pino y exportar un logger personalizado:

```typescript
import pino from "pino";
import { config } from "../config";

const { ENV } = config;

export const logger = pino({
  transport: {
    target: "pino-pretty",
    options: {
      colorize: true,
    },
  },
  level: ENV === "production" ? "info" : "debug",
});
```

Luego, integra Pino en tu servidor Express. Edita el archivo `src/libs/server.ts` para importar y usar Pino como un nuevo middleware de Express, recuerda importar el `logger` que acabas de crear:

```typescript
import pinoHttp from "pino-http";
import { logger } from "./logger";

// Middleware
app.use(pinoHttp({ logger }));
```

Tambien podemos usar Pino para registar el evento que indica que el servidor estÃ¡ corriendo, para ello edita el archivo `src/index.ts` y modifica el mensaje de inicio del servidor por el siguiente:

```typescript
logger.info(
  `ğŸš€ Server is up and running! Access it at: http://localhost:${PORT}/api/health-check`,
);
```

> ğŸ“š Â¿CuÃ¡l es la diferencia entre pino y pino-http?
>
> - `pino` es un logger rÃ¡pido para registrar eventos generales en la aplicaciÃ³n.
> - `pino-http` es un middleware de Express que captura automÃ¡ticamente las solicitudes HTTP y las registra en el log.
>
> Usamos pino-http({ logger }) en server.ts para que todas las peticiones queden registradas automÃ¡ticamente.

Luego de instalar y configurar Pino, ejecuta tu servidor con `npm run dev` y verifica que los eventos y errores se registren correctamente en la consola.

```bash
# Salida esperada
> tsx watch --env-file=.env src/index.ts

[01:41:32.832] INFO (160460): ğŸš€ Server is up and running! Access it at: http://localhost:3000/api/health-check
```

### Criterios de AceptaciÃ³n del Paso 9

- [ ] DeberÃ¡s instalar la librerÃ­a `pino` para el logging y configurarla en tu proyecto.
- [ ] DeberÃ¡s crear un archivo `src/libs/logger.ts` para configurar Pino y exportar un logger personalizado.
- [ ] DeberÃ¡s integrar Pino en tu servidor Express como un middleware.
- [ ] DeberÃ¡s crear un archivo `src/libs/datadog.ts` para configurar Datadog y exportar el agente.
- [ ] DeberÃ¡s verificar que el logging y la integraciÃ³n con Datadog funcionen correctamente en tu aplicaciÃ³n.

### ğŸ‰ Â¡Felicitaciones!

Has hecho avances muy impresionantes en tu proyecto, y mejorado la infraestructura de tu API con herramientas de observabilidad y monitoreo que son claves para escalar y mantener aplicaciones en producciÃ³n. Â¡Sigue asÃ­!

## Paso 10: Le pongamos estilo a nuestro cÃ³digo con Biome

En este paso, vamos a asegurarnos que el cÃ³digo de nuestra API siga las mejores prÃ¡cticas y estÃ¡ndares de codificaciÃ³n. Para ello, vamos a utilizar Biome, su extensiÃ³n para vscode y definiremos un estilo de cÃ³digo minimalista.

### Instalar la extensiÃ³n de Biome para Visual Studio Code

La extensiÃ³n de Biome para Visual Studio Code proporciona una integraciÃ³n perfecta con la herramienta de anÃ¡lisis de cÃ³digo estÃ¡tico. Vamos a instalar la extensiÃ³n para mejorar la experiencia de desarrollo.

Abre Visual Studio Code y busca la extensiÃ³n "Biome" en el Marketplace. Haz clic en "Install" para instalar la extensiÃ³n.

### InstalaciÃ³n de Biome

Biome es una herramienta de anÃ¡lisis de cÃ³digo estÃ¡tico que ayuda a mantener un cÃ³digo limpio y consistente. Vamos a instalar Biome y su extensiÃ³n para Visual Studio Code.

Ejecuta el siguiente comando en tu terminal para instalar Biome:

```bash
npm install -D @biomejs/biome
npx @biomejs/biome init
```

### ConfiguraciÃ³n de Biome

Reemplaza el contenido de archivo `biome.json` recientemente creado en la raÃ­z de tu proyecto con el siguiente contenido:

```json
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "correctness": {
        "noUnusedImports": "warn",
        "noUnusedVariables": "warn",
        "noUnusedFunctionParameters": "warn"
      },
      "recommended": true
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "single",
      "semicolons": "asNeeded"
    }
  }
}
```

### Script que corrige automÃ¡ticamente los errores de estilo

Agrega el siguiente script en la secciÃ³n "scripts" de tu archivo `package.json`:

```json
{
  "scripts": {
    "check": "biome check --write ."
  }
}
```

### ConfiguraciÃ³n de Visual Studio Code

Abre las configuraciones de Visual Studio Code presionando `Shift + Ctrl + P` y selecciona "Preferences: Open User Settings (JSON)". Agrega la siguiente configuraciÃ³n para que Biome chequeÃ© automÃ¡ticamente tu cÃ³digo al guardar:

```json
{
  // MantÃ©n el resto de configuraciones
  "editor.formatOnSave": true,
  "[javascript]": {
    "editor.defaultFormatter": "biomejs.biome"
  },
  "[typescript]": {
    "editor.defaultFormatter": "biomejs.biome"
  },
  "[json]": {
    "editor.defaultFormatter": "biomejs.biome"
  },
  "[jsonc]": {
    "editor.defaultFormatter": "vscode.json-language-features"
  }
}
```

### Da formato a tu cÃ³digo con Biome

Ejecuta el siguiente comando en tu terminal para dar formato a tu cÃ³digo con Biome:

```bash
npm run check
```

Esto formatearÃ¡ automÃ¡ticamente TODO tu cÃ³digo segÃºn las reglas definidas en el archivo `biome.json` por lo que verÃ¡s muchos cambios en tus archivos. Si ingresas a ver esos cambios verÃ¡s que Biome ha corregido automÃ¡ticamente los errores de estilo en tu cÃ³digo uniformando el estilo de todo tu proyecto.

ğŸ’¡ Este es un buen momento para hacer un commit con todo tu cÃ³digo formateado. Antes de hacerlo, asegÃºrate de que tu servidor funcione correctamente y que todas las pruebas unitarias se ejecuten sin errores.

### Criterios de AceptaciÃ³n del Paso 10

- [ ] DeberÃ¡s instalar la extensiÃ³n de Biome para Visual Studio Code.
- [ ] DeberÃ¡s instalar Biome y configurarlo en tu proyecto.
- [ ] DeberÃ¡s agregar un script en el archivo `package.json` para corregir automÃ¡ticamente los errores de estilo.
- [ ] DeberÃ¡s configurar Visual Studio Code para que Biome chequeÃ© automÃ¡ticamente tu cÃ³digo al guardar.
- [ ] DeberÃ¡s verificar que Biome funcione correctamente y corrija los errores de estilo en tu cÃ³digo.
- [ ] DeberÃ¡s chequear tu cÃ³digo con Biome y corregir los errores de estilo.
- [ ] Deberas verificar que las pruebas unitarias sigan pasando despuÃ©s de dar formato a tu cÃ³digo.

### ğŸ‰ Â¡Felicitaciones!

Has mejorado la calidad y consistencia de tu cÃ³digo con Biome, una herramienta de anÃ¡lisis de cÃ³digo estÃ¡tico que te ayudarÃ¡ a mantener un cÃ³digo limpio y consistente. Â¡Sigue asÃ­!

## Paso 11: RefactorizaciÃ³n del CRUD con Servicios y Controladores

En este paso, vamos a refactorizar el cÃ³digo de nuestra API para seguir una arquitectura mÃ¡s escalable y mantenible. Vamos a separar la lÃ³gica de negocio en servicios y controladores para mejorar la organizaciÃ³n y reutilizaciÃ³n del cÃ³digo. AdemÃ¡s vamos a implementar una arquitectura en capas (Layered Architecture) que es mÃ¡s escalable y mantenible.

### Agreguemos los typos necesarios

Antes de continuar con la refactorizaciÃ³n, necesitamos agregar los tipos necesarios para TypeScript. Crea un archivo `src/api/products/products.interfaces.ts` y agrega el siguiente cÃ³digo:

```typescript
// Interface para el objeto Producto
export type ProductDTO = {
  id: number;
  title: string;
  brand: string;
  category: string;
  price: number;
  stock: number;
}

// Interface para crear un nuevo producto
export type CreateProductDTO = Omit<ProductDTO, "id">;

// Interface para actualizar un producto existente
export type UpdateProductDTO = Partial<ProductDTO>;
```

Estas interfaces nos ayudarÃ¡n a definir la forma de los objetos de producto, asÃ­ como los datos necesarios para crear y actualizar un producto.

### Creemos la estructura de carpetas

Organizaremos los servicios y controladores en mÃ³dulos dentro del directorio `src/api`. Cada mÃ³dulo representarÃ¡ un recurso de la aplicaciÃ³n, como products y users.

```bash
src/
â”‚â”€â”€ api/
â”‚   â”œâ”€â”€ health-check/
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ health-check.route.ts
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ products.routes.ts
â”‚   â”œâ”€â”€ users/ # Ejemplo de un mÃ³dulo de usuarios
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ users.route.ts
â”‚   â”œâ”€â”€ orders/ # Ejemplo de un mÃ³dulo de Ã³rdenes
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ orders.route.ts
â”‚   â”œâ”€â”€ ... # Otros mÃ³dulos
```

> ğŸ“š SeparaciÃ³n en mÃ³dulos: La separaciÃ³n en mÃ³dulos es una tÃ©cnica de diseÃ±o de software que consiste en dividir una aplicaciÃ³n en partes mÃ¡s pequeÃ±as y manejables. Cada mÃ³dulo se enfoca en una tarea especÃ­fica y se comunica con otros mÃ³dulos a travÃ©s de interfaces bien definidas.

### Creemos nuestro primer Servicio

Crea un archivo `src/api/products/services/products.get.all.service.ts` y agrega el siguiente cÃ³digo:

```typescript
import { products } from "../../../data/products";

export const getAllProductsService = () => {
  return products;
};
```

### Creemos el primer Controlador

Crea un archivo `src/api/products/controllers/products.get.all.controller.ts` y agrega el siguiente cÃ³digo:

```typescript
import type { Request, Response } from "express";
import { getAllProductsService } from "../services/products.get.all.service";

export const getAllProductsController = (_req: Request, res: Response) => {
  const allProducts = getAllProductsService();
  res.json(allProducts);
};
```

### Creemos la Ruta para los Productos

Crea un archivo `src/api/products/products.routes.ts` y agrega el siguiente cÃ³digo:

```typescript
import { Router } from "express";
import { getAllProductsController } from "./controllers/products.get.all.controller";

export const productsRoutes = Router();

productsRoutes.get("/", getAllProductsController);
```

### Integremos la Ruta en el Servidor

Edita el archivo `src/libs/server.ts` para importar y usar la ruta de productos y eliminar las rutas antiguas:

```typescript
import cors from "cors";
import express from "express";
import pinoHttp from "pino-http";
import { healthCheckRoutes } from "../api/health-check/health-check.routes";
import { productsRoutes } from "../api/products/products.routes";
import { logger } from "./logger";

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(pinoHttp({ logger }));

// Rutas
app.use("/api/health-check", healthCheckRoutes);
app.use("/api/products", productsRoutes);

// Exportar el servidor para usarlo en index.ts
export { app };
```

### Refactorizamos la ruta de creaciÃ³n de productos

Crea un archivo `src/api/products/services/products.create.service.ts` y agrega el siguiente cÃ³digo:

```typescript
import { products } from "../../../data/products";
import { CreateProductDTO } from "../products.interfaces";

export const createProductService = (newProduct: CreateProductDTO) => {
  const id = products.length + 1;
  const product = { id, ...newProduct };
  products.push(product);
  return product;
};
```

Crea un archivo `src/api/products/controllers/products.create.controller.ts` y agrega el siguiente cÃ³digo:

```typescript
import type { Request, Response } from "express";
import { createProductService } from "../services/products.create.service";

export const createProductController = (req: Request, res: Response) => {
  const newProduct = req.body;
  const product = createProductService(newProduct);
  res.status(201).json(product);
};
```

Modifica el archivo `src/api/products/products.routes.ts` y agrega el siguiente cÃ³digo:

```typescript
import { Router } from "express";
import { createProductController } from "./controllers/products.create.controller";
import { getAllProductsController } from "./controllers/products.get.all.controller";

export const productsRoutes = Router();

productsRoutes.get("/", getAllProductsController);
productsRoutes.post("/", createProductController);
```

### Tu guÃ­a de desarrollo deben ser la pruebas unitarias

Si ejecutas las pruebas unitarias ahora, es posible que algunas fallen debido a la refactorizaciÃ³n. AsegÃºrate de refactorizar las rutas PUT y DELETE siguiendo el mismo proceso hasta que las pruebas pasen correctamente.

```bash
  RERUN  rerun all tests 

 âœ“ src/tests/products.get.test.ts (1 test) 39ms
   âœ“ GET /api/products > should return a list of products
 â¯ src/tests/products.delete.test.ts (2 tests | 2 failed) 66ms
   Ã— DELETE /api/products/:id > should delete an existing product 49ms
     â†’ expected 404 to be 200 // Object.is equality
   Ã— DELETE /api/products/:id > should return 404 if product not found 16ms
     â†’ expected {} to match object { message: 'Product not found' }
 âœ“ src/tests/health-check.get.test.ts (1 test) 39ms
   âœ“ GET /api/health-check > should return { status: 'ready' }
 â¯ src/tests/products.put.test.ts (2 tests | 2 failed) 78ms
   Ã— PUT /api/products/:id > should update an existing product 64ms
     â†’ expected 404 to be 200 // Object.is equality
   Ã— PUT /api/products/:id > should return 404 if product not found 13ms
     â†’ expected {} to match object { message: 'Product not found' }
 âœ“ src/tests/products.post.test.ts (1 test) 42ms
   âœ“ POST /api/products > should create a new product
```

### Refactoriza el resto de las rutas

Mueve la lÃ³gica de negocio del archivo `src/routes/products.ts` a los servicios y controladores correspondientes en el directorio `src/api/products`. Repite el proceso para las rutas de creaciÃ³n, actualizaciÃ³n y eliminaciÃ³n de productos.

ğŸ’¡ Usa GitHub Copilot o ChatGPT para obtener sugerencias y asistencia mientras desarrollas tu API. Estas herramientas pueden ayudarte a escribir cÃ³digo mÃ¡s rÃ¡pido y a resolver problemas comunes de programaciÃ³n.

âš ï¸ Recuerda que por cada ruta deberÃ¡s crear un servicio y un controlador correspondiente, ademÃ¡s de crear la ruta en el archivo `src/api/products/products.routes.ts` y verificar que el test unitario correspondiente pase correctamente.

La estructura de carpetas y archivos deberÃ­a verse asÃ­:

```bash
src/
â”‚â”€â”€ api/
â”‚   â”œâ”€â”€   /
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ health-check.get.controller.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ health-check.get.service.ts
â”‚   â”‚   â”œâ”€â”€ health-check.routes.ts
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ products.get.all.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ products.create.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ products.update.controller.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ products.delete.controller.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ products.get.all.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ products.create.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ products.update.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ products.delete.service.ts
â”‚   â”‚   â”œâ”€â”€ products.routes.ts
```

âš ï¸ Ya puedes eliminar el archivo `src/routes/products.ts`.
Luego ejecuta los tests para verificar que todo sigue funcionando correctamente, y has los ajustes necesarios en caso de que algo falle.

### Criterios de AceptaciÃ³n del Paso 11

- [ ] DeberÃ¡s crear una estructura de carpetas y archivos para los servicios y controladores de la API.
- [ ] DeberÃ¡s crear servicios y controladores para las operaciones CRUD de los productos.
- [ ] DeberÃ¡s crear interfaces para los objetos de producto y los datos necesarios para crear y actualizar un producto.
- [ ] DeberÃ¡s refactorizar las rutas de productos para seguir una arquitectura en capas.
- [ ] DeberÃ¡s mover la lÃ³gica de negocio de las rutas a los servicios y controladores correspondientes.
- [ ] DeberÃ¡s integrar las rutas de productos en el servidor Express y eliminar las rutas antiguas.
- [ ] DeberÃ¡s verificar que las rutas de productos funcionen correctamente despuÃ©s de la refactorizaciÃ³n.

### ğŸ‰ Â¡Felicitaciones!

Has refactorizado tu API para seguir una arquitectura mÃ¡s escalable y mantenible, utilizando servicios y controladores para separar la lÃ³gica de negocio de las rutas. Â¡Sigue asÃ­!

## Paso 12: Implementar una base de datos PostgreSQL con Prisma

En este paso, vamos a implementar una base de datos PostgreSQL con Prisma, un ORM moderno y seguro para Node.js y TypeScript. Prisma nos permitirÃ¡ interactuar con la base de datos de forma segura y eficiente, y nos facilitarÃ¡ la implementaciÃ³n de consultas y migraciones de esquema.

Antes de comenzar con el cÃ³digo, necesitas hacer lo siguiente:

1. Crea una cuenta en Prisma ORM.
2. Crea un nuevo proyecto en la Prisma Console. Te sugerimos el nombre api-stock.
3. Crea una base de datos Prisma PostgreSQL. Este proceso tomarÃ¡ unos minutos.
4. Copia tu `DATABASE_URL` y agregalo en el archivo `.env` de tu proyecto.
5. Copia tu DATABASE_URL y agrÃ©galo en el archivo .env de tu proyecto.

Listo, ya podemos comenzar con la implementaciÃ³n de Prisma ORM

### InstalaciÃ³n de Prisma

Ejecuta el siguiente comando en tu terminal para instalar Prisma CLI y Prisma Client:

```bash
npm install -D prisma
npx prisma init
```

### ConfiguraciÃ³n de Prisma

Luego de inicializar Prisma, se crearÃ¡ un archivo `prisma/schema.prisma` con la configuraciÃ³n de la base de datos. Este archivo es clave para definir el esquema de la base de datos y las tablas que vamos a utilizar en nuestra aplicaciÃ³n y la relaciÃ³n entre ellas.

Edita el archivo `prisma/schema.prisma` y reemplÃ¡zalo con el siguiente cÃ³digo:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Configuration {
  id            String   @id @default(cuid())
  currency      String
  cents         Int
  negativeStock Boolean
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  displayName String?
  password    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Product {
  id         String          @id @default(cuid())
  title      String
  price      Int
  stock      Int
  brand      ProductBrand    @relation(fields: [brandId], references: [id], onDelete: Cascade)
  brandId    String
  category   ProductCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId String
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
}

model ProductBrand {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  Product   Product[]

  @@map("product_brand")
}

model ProductCategory {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  Product   Product[]

  @@map("product_category")
}
```

Hemos creado 5 modelos en el archivo `prisma/schema.prisma`:

- `Configuration`: ConfiguraciÃ³n de la aplicaciÃ³n, como la moneda y la cantidad de decimales. (Lo necesitarÃ¡s mÃ¡s adelante)
- `User`: Usuarios de la aplicaciÃ³n, con un email, nombre de usuario y contraseÃ±a. (Lo necesitarÃ¡s mÃ¡s adelante)
- `Product`: Productos de la aplicaciÃ³n, con un tÃ­tulo, precio, stock, marca y categorÃ­a.
- `ProductBrand`: Marcas de los productos, con un nombre.
- `ProductCategory`: CategorÃ­as de los productos, con un nombre.

Cada modelo tiene campos y relaciones que definen la estructura de la base de datos. Si quieres aprender mÃ¡s sobre el modelado de datos en Prisma, consulta la [documentaciÃ³n oficial de Prisma](https://www.prisma.io/docs/orm/prisma-schema/data-model/models).

### GeneraciÃ³n de Migraciones y Prisma Client

> ğŸ“š Â¿Que son las migraciones en Prisma ORM? Las migraciones en Prisma ORM son cambios en el esquema de la base de datos que se aplican de forma incremental y controlada. Las migraciones permiten modificar la estructura de la base de datos sin perder datos existentes.

Ejecuta los siguientes comandos en tu terminal para generar tu primera migraciÃ³n y generar el Prisma Client:

```bash
npx prisma migrate dev --name init
npx prisma generate
```

### InstalaciÃ³n de Prisma Client

Prisma Client es una biblioteca de base de datos generada automÃ¡ticamente que se utiliza para interactuar con la base de datos PostgreSQL. Vamos a instalar Prisma Client en nuestra aplicaciÃ³n para realizar consultas y operaciones en la base de datos.

En tu terminal:

```bash
npm install @prisma/client
```

AdemÃ¡s vamos a modificar el archivo `package.json` para agregar un script que genere el Prisma Client automÃ¡ticamente despuÃ©s de cada migraciÃ³n:

```json
{
  "scripts": {
    "prisma:generate": "npx prisma generate"
  }
}
```

### ConfiguraciÃ³n de Prisma Client

Crea un archivo `src/libs/prisma.ts` para configurar y exportar el Prisma Client:

```typescript
import { PrismaClient } from "@prisma/client";
import { logger } from "./logger";

export const DB = new PrismaClient();

DB.$connect()
  .then(() => {
    logger.info("ğŸ’¾ Database connected successfully");
  })
  .catch((error) => {
    logger.fatal(error, "ğŸ’¾ Database connection error");
    throw error;
  });

process.on("beforeExit", async () => {
  await DB.$disconnect();
  logger.info("ğŸ’¾ Database connection closed");
});
```

### IntegraciÃ³n de Prisma Client en el Servidor

Agrega al archivo `src/index.ts` la importaciÃ³n del cliente de Prisma para que se conecte a la base de datos al iniciar el servidor:

```typescript
import "./libs/prisma";
```

### Criterios de AceptaciÃ³n del Paso 12

- [ ] DeberÃ¡s crear una cuenta en Prisma y configurar una base de datos PostgreSQL.
- [ ] DeberÃ¡s obtener el string de conexiÃ³n DATABASE_URL y agregarlo en el archivo .env.
- [ ] DeberÃ¡s instalar Prisma CLI y Prisma Client en tu proyecto.
- [ ] DeberÃ¡s configurar el archivo prisma/schema.prisma con los modelos y relaciones de la base de datos.
- [ ] DeberÃ¡s generar la primera migraciÃ³n y el Prisma Client.
- [ ] DeberÃ¡s configurar y exportar el Prisma Client en un archivo src/libs/prisma.ts.

### ğŸ‰ Â¡Felicitaciones!

Has implementado una base de datos PostgreSQL con Prisma, un ORM moderno y seguro para Node.js y TypeScript. Prisma te permitirÃ¡ interactuar con la base de datos de forma segura y eficiente, y facilitarÃ¡ la implementaciÃ³n de consultas y migraciones de esquema. Â¡Sigue asÃ­!

## Paso 13: Manejo de Errores y Validaciones Avanzadas

En este paso, vamos a implementar un middleware de manejo de errores y validaciones avanzadas utilizando Zod. Esto nos permitirÃ¡ estandarizar las respuestas de error y asegurarnos de que los datos recibidos en las solicitudes sean vÃ¡lidos.

> ğŸ“š Â¿QuÃ© es Zod? Zod es una biblioteca de validaciÃ³n de esquemas para TypeScript y JavaScript. Permite definir esquemas de datos y validar objetos de manera declarativa y segura.

### InstalaciÃ³n de Zod

Primero, necesitamos instalar Zod, una biblioteca de validaciÃ³n de esquemas para TypeScript.

Ejecuta el siguiente comando en tu terminal:

```bash
npm install zod
```

### CreaciÃ³n del Middleware de Manejo de Errores

Vamos a crear un middleware para manejar los errores de forma centralizada. Crea un archivo `src/middleware/errorHandler.ts` y agrega el siguiente cÃ³digo:

```typescript
import type { NextFunction, Request, Response } from "express";
import { ZodError } from "zod";
import { logger } from "../libs/logger";

export const errorHandler = (
  err: any,
  _req: Request,
  res: Response,
  _next: NextFunction,
) => {
  if (err instanceof ZodError) {
    return res.status(400).json({
      message: "Validation error",
      errors: err.errors,
    });
  }

  logger.error(err);
  res.status(500).json({
    message: "Internal server error",
  });
};
```

### IntegraciÃ³n del Middleware en el Servidor

Edita el archivo `src/libs/server.ts` para usar el middleware de manejo de errores:

```typescript
import cors from "cors";
import express from "express";
import pinoHttp from "pino-http";
import { healthCheckRoutes } from "../api/health-check/health-check.routes";
import { productsRoutes } from "../api/products/products.routes";
import { errorHandler } from "../middleware/errorHandler";
import { logger } from "./logger";

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(pinoHttp({ logger }));

// Routes
app.use("/api/health-check", healthCheckRoutes);
app.use("/api/products", productsRoutes);

// Error handling middleware
app.use(errorHandler);

// Exportar el servidor para usarlo en index.ts
export { app };
```

### Validaciones con Zod

Vamos a crear un esquema de validaciÃ³n para los productos utilizando Zod. Crea un archivo `src/api/products/schemas/product.schema.ts` y agrega el siguiente cÃ³digo:

```typescript
import { z } from "zod";

export const productSchema = z.object({
  title: z.string().min(1, "Title is required"),
  brand: z.string().min(1, "Brand is required"),
  category: z.string().min(1, "Category is required"),
  price: z.number().positive("Price must be a positive number"),
  stock: z.number().int().nonnegative("Stock must be a non-negative integer"),
});
```

### ValidaciÃ³n en el Controlador de CreaciÃ³n de Productos

Edita el archivo `src/api/products/controllers/products.create.controller.ts` para validar los datos del producto antes de crear uno nuevo:

```typescript
import type { Request, Response } from "express";
import { productSchema } from "../schemas/product.schema";
import { createProductService } from "../services/products.create.service";

export const createProductController = (req: Request, res: Response) => {
  const validationResult = productSchema.safeParse(req.body);

  if (!validationResult.success) {
    throw validationResult.error;
  }

  const newProduct = createProductService(validationResult.data);
  res.status(201).json(newProduct);
};
```

> ğŸ’¡ Es importante usar `safeParse` de Zod para filtrar cualquier dato sensible en la respuesta y asegurarse de que solo los datos vÃ¡lidos sean procesados.

### Criterios de AceptaciÃ³n del Paso 13

- [ ] DeberÃ¡s instalar la librerÃ­a `zod` para validaciones.
- [ ] DeberÃ¡s crear un middleware de manejo de errores en `src/middleware/errorHandler.ts`.
- [ ] DeberÃ¡s integrar el middleware de manejo de errores en el servidor Express.
- [ ] DeberÃ¡s crear un esquema de validaciÃ³n para los productos en `src/api/products/schemas/product.schema.ts`.
- [ ] DeberÃ¡s validar los datos del producto en el controlador de creaciÃ³n de productos.

### ğŸ‰ Â¡Felicitaciones!

Has implementado un middleware de manejo de errores y validaciones avanzadas utilizando Zod. Esto te permitirÃ¡ estandarizar las respuestas de error y asegurarte de que los datos recibidos en las solicitudes sean vÃ¡lidos. Â¡Sigue asÃ­!

## Paso 14: Adaptar Servicios para Usar Base de Datos Real

En este paso, vamos a actualizar los servicios de tu API de productos para que, en lugar de usar datos mockeados (como arrays en memoria), realicen operaciones reales contra la base de datos PostgreSQL a travÃ©s de Prisma. Esto significa que modificarÃ¡s los servicios de obtenciÃ³n, creaciÃ³n, actualizaciÃ³n y eliminaciÃ³n de productos para que interactÃºen directamente con las tablas definidas en tu modelo Prisma (por ejemplo, la tabla `Product` y sus relaciones con `ProductBrand` y `ProductCategory`). AdemÃ¡s, ajustaremos los controladores correspondientes para manejar las operaciones asÃ­ncronas y los errores de forma correcta.

La integraciÃ³n con la base de datos se realizarÃ¡ utilizando la instancia de Prisma Client configurada en `src/libs/prisma.ts`. Con estos cambios, tu API trabajarÃ¡ con datos persistentes y podrÃ¡s aplicar consultas reales, transacciones y operaciones complejas en la base de datos.

### 1. Servicio para Obtener Todos los Productos

Actualiza el servicio para obtener todos los productos consultando la base de datos.

Modifica el archivo `src/api/products/services/products.get.all.service.ts`:

```typescript
import { DB } from "../../../libs/prisma";

export const getAllProductsService = async () => {
  const products = await DB.product.findMany({
    include: {
      brand: true,
      category: true,
    },
  });
  return products;
};
```

### 2. Servicio para Crear un Producto

Actualiza el servicio de creaciÃ³n para insertar un nuevo producto en la base de datos. Se consultarÃ¡n las entidades relacionadas (marca y categorÃ­a) antes de crear el producto.

Modifica el archivo `src/api/products/services/products.create.service.ts`:

```typescript
import { DB } from "../../../libs/prisma";

export interface CreateProductData {
  title: string;
  brand: string;
  category: string;
  price: number;
  stock: number;
}

export const createProductService = async (data: CreateProductData) => {
  // Buscar la marca y categorÃ­a por nombre
  const brandRecord = await DB.productBrand.findFirst({
    where: { name: data.brand },
  });
  const categoryRecord = await DB.productCategory.findFirst({
    where: { name: data.category },
  });

  if (!brandRecord || !categoryRecord) {
    throw new Error("La marca o categorÃ­a no existen en la base de datos");
  }

  const newProduct = await DB.product.create({
    data: {
      title: data.title,
      price: Math.floor(data.price), // Asegurarse de que el precio sea un entero
      stock: data.stock,
      brandId: brandRecord.id,
      categoryId: categoryRecord.id,
    },
    include: {
      brand: true,
      category: true,
    },
  });

  return newProduct;
};
```

### 3. Servicio para Actualizar un Producto

Actualiza el servicio para modificar un producto existente. Se leerÃ¡n los posibles cambios, incluyendo la actualizaciÃ³n de la marca y/o categorÃ­a, validando y obteniendo sus IDs correspondientes.

Modifica el archivo `src/api/products/services/products.update.service.ts`:

```typescript
import { DB } from "../../../libs/prisma";

export interface UpdateProductData {
  title?: string;
  brand?: string;
  category?: string;
  price?: number;
  stock?: number;
}

export const updateProductService = async (
  id: string,
  data: UpdateProductData,
) => {
  let brandId: string | undefined;
  let categoryId: string | undefined;

  if (data.brand) {
    const brandRecord = await DB.productBrand.findFirst({
      where: { name: data.brand },
    });
    if (!brandRecord) {
      throw new Error("Marca no encontrada");
    }
    brandId = brandRecord.id;
  }
  if (data.category) {
    const categoryRecord = await DB.productCategory.findFirst({
      where: { name: data.category },
    });
    if (!categoryRecord) {
      throw new Error("CategorÃ­a no encontrada");
    }
    categoryId = categoryRecord.id;
  }

  const updatedProduct = await DB.product.update({
    where: { id },
    data: {
      title: data.title,
      price: data.price !== undefined ? Math.floor(data.price) : undefined,
      stock: data.stock,
      ...(brandId && { brandId }),
      ...(categoryId && { categoryId }),
    },
    include: {
      brand: true,
      category: true,
    },
  });

  return updatedProduct;
};
```

### 4. Servicio para Eliminar un Producto

Actualiza el servicio para eliminar un producto, validando que existe en la base de datos antes de borrar el registro.

Modifica el archivo `src/api/products/services/products.delete.service.ts`:

```typescript
import { DB } from "../../../libs/prisma";

export const deleteProductService = async (id: string) => {
  const productToDelete = await DB.product.findUnique({ where: { id } });
  if (!productToDelete) {
    throw new Error("Product not found");
  }

  await DB.product.delete({
    where: { id },
  });

  return { message: "Product deleted", id };
};
```

### 5. ActualizaciÃ³n de los Controladores

Modifica los controladores para utilizar las funciones de los servicios adaptadas a Prisma y para manejar correctamente las operaciones asÃ­ncronas y los errores.

Para modificar el controlador para Crear un Producto, modifica el archivo `src/api/products/controllers/products.create.controller.ts`:

```typescript
import type { Request, Response } from "express";
import { productSchema } from "../schemas/product.schema";
import { createProductService } from "../services/products.create.service";

export const createProductController = async (req: Request, res: Response) => {
  const validationResult = productSchema.safeParse(req.body);

  if (!validationResult.success) {
    return res.status(400).json({
      message: "Validation error",
      errors: validationResult.error.errors,
    });
  }

  try {
    const newProduct = await createProductService(validationResult.data);
    res.status(201).json(newProduct);
  } catch (error: any) {
    res.status(500).json({ message: error.message });
  }
};
```

Para modificar el controlador para Actualizar un Producto, modifica el archivo `src/api/products/controllers/products.update.controller.ts`:

```typescript
import type { Request, Response } from "express";
import { productSchema } from "../schemas/product.schema"; // (Opcional: para validar datos)
import { updateProductService } from "../services/products.update.service";

export const updateProductController = async (req: Request, res: Response) => {
  const { id } = req.params;
  const validationResult = productSchema.safeParse(req.body);

  if (!validationResult.success) {
    return res.status(400).json({
      message: "Validation error",
      errors: validationResult.error.errors,
    });
  }

  try {
    const updatedProduct = await updateProductService(
      id,
      validationResult.data,
    );
    res.status(200).json(updatedProduct);
  } catch (error: any) {
    if (
      error.message === "Marca no encontrada"
      || error.message === "CategorÃ­a no encontrada"
    ) {
      return res.status(404).json({ message: error.message });
    }
    res.status(500).json({ message: error.message });
  }
};
```

Para modificar el controlador para Eliminar un Producto, modifica el archivo `src/api/products/controllers/products.delete.controller.ts`:

```typescript
import type { Request, Response } from "express";
import { deleteProductService } from "../services/products.delete.service";

export const deleteProductController = async (req: Request, res: Response) => {
  const { id } = req.params;

  try {
    const result = await deleteProductService(id);
    res.status(200).json(result);
  } catch (error: any) {
    if (error.message === "Product not found") {
      return res.status(404).json({ message: error.message });
    }
    res.status(500).json({ message: error.message });
  }
};
```

ğŸ’¡ Es una buena prÃ¡ctica utilizar Zod dentro de cada servicio para validar tanto los datos de entrada como los datos de salida. Esto asegura que los datos que se procesan y se devuelven cumplen con los esquemas definidos, lo que ayuda a prevenir errores y a mantener la integridad de los datos en toda la aplicaciÃ³n.

Por ejemplo, puedes definir un esquema de validaciÃ³n para los datos de entrada en el servicio de creaciÃ³n de productos y otro esquema para los datos de salida:

Crea un archivo `src/api/products/schemas/product.schema.ts` y agrega los esquemas de validaciÃ³n:

```typescript
import { z } from "zod";

const createProductInputSchema = z.object({
  title: z.string().min(1, "Title is required"),
  brand: z.string().min(1, "Brand is required"),
  category: z.string().min(1, "Category is required"),
  price: z.number().positive("Price must be a positive number"),
  stock: z.number().int().nonnegative("Stock must be a non-negative integer"),
});

const createProductOutputSchema = z.object({
  id: z.string(),
  title: z.string(),
  brand: z.string(),
  category: z.string(),
  price: z.number(),
  stock: z.number(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export const createProductService = async (data: CreateProductData) => {
  const validationResult = createProductInputSchema.safeParse(data);

  if (!validationResult.success) {
    throw new Error("Validation error");
  }

  // LÃ³gica para crear el producto en la base de datos
  const newProduct = await DB.product.create({
    data: validationResult.data,
    include: {
      brand: true,
      category: true,
    },
  });

  const outputValidationResult = createProductOutputSchema.safeParse(
    newProduct,
  );

  if (!outputValidationResult.success) {
    throw new Error("Output validation error");
  }

  return outputValidationResult.data;
};
```

De esta manera, aseguras que tanto los datos de entrada como los datos de salida cumplen con los esquemas definidos, lo que mejora la robustez y la confiabilidad de tu aplicaciÃ³n. Te invitamos a crear schemas para los demÃ¡s servicios y controladores siguiendo esta misma lÃ³gica.

### Criterios de AceptaciÃ³n del Paso 14

- [ ] Actualizar el servicio de obtenciÃ³n de productos en `src/api/products/services/products.get.all.service.ts` para consultar la base de datos usando Prisma.
- [ ] Actualizar el servicio de creaciÃ³n en `src/api/products/services/products.create.service.ts` para insertar un nuevo producto, validando y consultando las relaciones de marca y categorÃ­a.
- [ ] Actualizar el servicio de actualizaciÃ³n en `src/api/products/services/products.update.service.ts` para modificar un producto existente.
- [ ] Actualizar el servicio de eliminaciÃ³n en `src/api/products/services/products.delete.service.ts` para remover el producto de la base de datos.
- [ ] Modificar los controladores en `src/api/products/controllers/` para utilizar las funciones asÃ­ncronas de los servicios y manejar errores de forma adecuada.
- [ ] Ejecutar las pruebas para verificar que las operaciones CRUD funcionan correctamente contra la base de datos real.

### ğŸ‰ Â¡Felicitaciones!

Has adaptado exitosamente tus servicios y controladores para interactuar con una base de datos PostgreSQL real mediante Prisma. Con estos cambios, tu API ahora trabajarÃ¡ con datos persistentes y estarÃ¡s un paso mÃ¡s cerca de construir una soluciÃ³n escalable y profesional. Â¡Sigue asÃ­ y continÃºa avanzando en el curso!

## Paso 15: Despliegue y ConfiguraciÃ³n en ProducciÃ³n

En este paso, desplegaremos tu API en Railway, una plataforma en la nube que facilita el hosting de aplicaciones. Aprovecharemos la base de datos PostgreSQL y la configuraciÃ³n de Prisma ya establecidas, y configuraremos las variables de entorno y logging para el ambiente de producciÃ³n.

### CreaciÃ³n de una Cuenta y Servicio en Railway

Si aÃºn no tienes una cuenta en Railway, puedes crear una gratuita visitando [Railway](https://railway.app/). Sigue estos pasos bÃ¡sicos:

1. RegÃ­strate con tu email o con tu cuenta de GitHub.
2. Una vez dentro, haz clic en **"New Project"**.
3. Selecciona la opciÃ³n **"Deploy from GitHub Repo"** y conecta tu repositorio.
4. Configura el servicio, asegurÃ¡ndote de establecer la variable `DATABASE_URL` (con el string de conexiÃ³n de tu base de datos PostgreSQL) y otras variables necesarias para la ejecuciÃ³n, como `NODE_ENV` con el valor `"production"`.
5. Railway generarÃ¡ una URL pÃºblica para acceder a tu API en producciÃ³n.

### ConfiguraciÃ³n de Variables de Entorno y Logs

1. **Variables de Entorno:**\
   AsegÃºrate de definir en Railway las siguientes variables:
   - `DATABASE_URL`: Conecta tu base de datos PostgreSQL.
   - `NODE_ENV`: Establecido a `"production"`.
   - Cualquier otra variable que tu aplicaciÃ³n requiera (por ejemplo, `PORT`).

2. **Logging en ProducciÃ³n:**\
   Revisa que en el archivo `src/libs/logger.ts` el nivel de log se configure segÃºn el entorno:
   ```typescript
   import pino from "pino";
   import { config } from "../config";

   const { ENV } = config;

   export const logger = pino({
     transport: {
       target: "pino-pretty",
       options: {
         colorize: true,
       },
     },
     level: ENV === "production" ? "info" : "debug",
   });
   ```
   Esto garantizarÃ¡ que en producciÃ³n se muestren logs a nivel `info` para evitar el exceso de informaciÃ³n.

### ActualizaciÃ³n del Script de Inicio

AsegÃºrate de que el script de inicio en tu `package.json` utilice el cÃ³digo compilado y respete las variables de entorno:

```json
{
  "scripts": {
    "start": "node --env-file=.env dist/index.js"
  }
}
```

> Nota: Railway manejarÃ¡ sus propias variables de entorno en el dashboard, por lo que es crucial que la variable `DATABASE_URL` y `NODE_ENV` estÃ©n correctamente definidas allÃ­.

### Pruebas y Validaciones Previas al Despliegue

Antes de desplegar, verifica los siguientes puntos:

- Ejecuta `npm test` para asegurarte de que todos los tests pasen.
- Comprueba el funcionamiento de la API en ambiente local en modo producciÃ³n:
  1. Compila el proyecto con `npm run build`.
  2. Inicia la aplicaciÃ³n con `npm start`.
- Revisa los logs para confirmar que no se presenten errores y que la conexiÃ³n a la base de datos sea exitosa.

Una vez validados estos pasos, realiza el despliegue en Railway siguiendo el proceso de importaciÃ³n del repositorio.

### SoluciÃ³n de Problemas Comunes

- VerificÃ¡ que las variables de entorno estÃ©n correctamente definidas.
- RevisÃ¡ los logs (usando Pino) para identificar problemas de conexiÃ³n a la base de datos.
- ProbÃ¡ localmente en modo producciÃ³n antes del despliegue:

```bash
npm run build
npm start
```

> ğŸ’¡ Consejo: Si se presentan errores en la conexiÃ³n a la base de datos, consultÃ¡ la documentaciÃ³n de Prisma y Railway.

### Criterios de AceptaciÃ³n del Paso 15

- [ ] DeberÃ¡s tener una cuenta en Railway (puedes crear una gratuita [aquÃ­](https://railway.app/)).
- [ ] DeberÃ¡s configurar en Railway las variables de entorno, incluyendo `DATABASE_URL` y `NODE_ENV=production`.
- [ ] La API deberÃ¡ conectarse correctamente a la base de datos PostgreSQL en el entorno de Railway.
- [ ] Los logs deben indicar que la aplicaciÃ³n se inicia sin errores y en modo producciÃ³n.
- [ ] DeberÃ¡s verificar el funcionamiento de la API en producciÃ³n accediendo a la URL proporcionada por Railway.

### ğŸ‰ Â¡Felicitaciones!

Has completado el despliegue de tu API en Railway, configurando adecuadamente las variables de entorno y los logs para el ambiente de producciÃ³n. Â¡Tu API ahora estÃ¡ lista para recibir trÃ¡fico real y crecer de forma escalable! Â¡Excelente trabajo y sigue adelante!

## Paso 16: ImplementaciÃ³n de CI/CD

En este paso, configuraremos GitHub Actions para automatizar las pruebas y el despliegue continuo de tu API. Con esta integraciÃ³n, cada vez que realices cambios en la rama principal se ejecutarÃ¡n los tests y, de estar todo correcto, se compilarÃ¡ y desplegarÃ¡ la aplicaciÃ³n. Esto te ayudarÃ¡ a detectar errores rÃ¡pidamente y a mantener un proceso de despliegue confiable y eficiente.

### CreaciÃ³n del Workflow en GitHub Actions

1. Dentro de tu repositorio, crea el directorio `.github/workflows`.
2. Crea un archivo llamado `ci-cd.yml` en dicho directorio.

En este archivo definirÃ¡s el workflow de CI/CD. Un ejemplo de configuraciÃ³n es el siguiente:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js environment
        uses: actions/setup-node@v3
        with:
          node-version: 16

      - name: Install dependencies
        run: npm install

      - name: Run tests
        run: npm test

      - name: Build project
        run: npm run build

      - name: Deploy to Railway
        if: github.ref == 'refs/heads/main'
        run: |
          npx railway deploy
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
```

> ğŸ“š Nota:
>
> - AsegÃºrate de tener configurado el secret `RAILWAY_TOKEN` en la secciÃ³n de secrets de tu repositorio en GitHub. Railway ofrece un CLI que permite desplegar tu servicio; si aÃºn no lo tienes instalado, puedes agregarlo a travÃ©s de `npx railway` en tus scripts.
> - Revisa que los scripts definidos en tu `package.json` (como `npm test` y `npm run build`) funcionen correctamente.

### Pruebas y Validaciones Previas al Despliegue

Antes de integrar el workflow de CI/CD, sigue estos pasos en local:

- Ejecuta `npm test` para confirmar que las pruebas pasen sin errores.
- Realiza la compilaciÃ³n con `npm run build` y verifica que no se produzcan errores.
- Si usas Railway, prueba manualmente el despliegue con `npx railway deploy` para asegurarte de que la conexiÃ³n y las variables de entorno estÃ¡n correctamente configuradas.

### Criterios de AceptaciÃ³n del Paso 16

- [ ] DeberÃ¡s crear el directorio `.github/workflows` en tu repositorio si aÃºn no existe.
- [ ] DeberÃ¡s crear un archivo `ci-cd.yml` que defina el workflow para ejecutar tests, compilar la aplicaciÃ³n y desplegarla.
- [ ] El workflow deberÃ¡ ejecutarse en cada push o pull request a la rama `main`.
- [ ] DeberÃ¡s tener configurado el secret `RAILWAY_TOKEN` en GitHub para el despliegue.
- [ ] Los tests deben correr y pasar, y el despliegue se debe ejecutar sin errores.

### ğŸ‰ Â¡Felicitaciones!

Has implementado con Ã©xito un pipeline de CI/CD utilizando GitHub Actions. Ahora, cada cambio en la rama principal activarÃ¡ automÃ¡ticamente pruebas y despliegues, lo que garantiza la calidad y la estabilidad de tu API en producciÃ³n. Â¡Excelente trabajo y sigue avanzando en tu aprendizaje!

> ğŸ’¡ Consejo: Revisa periÃ³dicamente los logs de GitHub Actions para detectar posibles fallos o Ã¡reas de mejora en tu pipeline de CI/CD.

## âš ï¸ Recuerda detener y eliminar cualquier instancia de tu API en Railway si ya no la necesitas para evitar costos innecesarios.

Si bien Railway ofrece un plan gratuito, es importante mantener un control de los recursos utilizados para evitar cargos adicionales. Si no estÃ¡s utilizando tu API en producciÃ³n, asegÃºrate de detener y eliminar cualquier instancia para evitar costos innecesarios.

# ğŸ Â¡Felicidades! Has completado el Curso de API REST con Node.js y TypeScript

Â¡Enhorabuena! Has completado el Curso de API REST con Node.js y TypeScript. Has aprendido a construir una API RESTful escalable y mantenible utilizando tecnologÃ­as modernas como Express, Prisma, Zod y Railway. Has implementado funcionalidades esenciales como CRUD de productos, servicios, controladores, validaciones, manejo de errores, base de datos PostgreSQL, despliegue en producciÃ³n y CI/CD. Â¡Excelente trabajo!

ğŸ’¡ Es fundamental que entiendas que este curso es solo el comienzo para convertirte en un gran desarrollador backend, pero que debes seguir aprendiendo y practicando con frecuencia para lograr tus objetivos. La prÃ¡ctica constante y la curiosidad por aprender nuevas tecnologÃ­as y mejores prÃ¡cticas te ayudarÃ¡n a mejorar tus habilidades y a mantenerte actualizado en un campo que evoluciona rÃ¡pidamente. Â¡Sigue adelante y nunca dejes de aprender!

# ğŸš€ Recursos Adicionale

- [Express.js](https://expressjs.com/): DocumentaciÃ³n oficial de Express.js.
- [Prisma](https://www.prisma.io/): DocumentaciÃ³n oficial de Prisma ORM.
- [Zod](https://zod.dev/): DocumentaciÃ³n oficial de Zod.
- [Railway](https://railway.app/): DocumentaciÃ³n oficial de Railway.
- [GitHub Actions](https://docs.github.com/en/actions): DocumentaciÃ³n oficial de GitHub Actions.
- [DocumentaciÃ³n de Pino](https://getpino.io/): DocumentaciÃ³n oficial de Pino.
- [Biome para vscode](https://marketplace.visualstudio.com/items?itemName=biomejs.biome): ExtensiÃ³n de Biome para Visual Studio Code.

# ğŸ”œ PrÃ³ximos Pasos

> ### âš ï¸ Importante: Esta guÃ­a se encuentra en desarrollo y puede sufrir cambios en el futuro. Si tienes alguna sugerencia o correcciÃ³n, no dudes en abrir un issue o una pull request. Â¡Gracias por tu colaboraciÃ³n!

- Paso 16: ImplementaciÃ³n de CI/CD
  - Configurar GitHub Actions para pruebas automatizadas y despliegue continuo.

# Pasos opcionales

Esta serie de pasos busca que el usuario continue en su aprendizaje incluyendo desafÃ­os mÃ¡s complejos y avanzados. Si deseas continuar con el curso, puedes seguir con los pasos opcionales.

- Opcional: Implementar PaginaciÃ³n y Filtros en Endpoints
  - Agregar paginaciÃ³n y filtros dinÃ¡micos en los endpoints.
  - Optimizar consultas para mejorar el rendimiento en grandes volÃºmenes de datos.

- Opcional: DocumentaciÃ³n AutomÃ¡tica con OpenAPI (Swagger)
  - Generar documentaciÃ³n interactiva para la API.
  - Agregar ejemplos de uso y esquemas de respuesta.
  - Permitir pruebas de endpoints directamente desde la documentaciÃ³n.

- Opcional: CRUD de Usuarios, Roles y AutenticaciÃ³n
  - Implementar endpoints para crear, leer, actualizar y eliminar usuarios y roles.
  - Agregar endpoints para obtener y refrescar tokens de acceso.
  - Implementar endpoints para asignar y revocar roles y permisos.
  - Implementar autenticaciÃ³n con JWT y Passport.
  - Implementar autorizaciÃ³n basada en roles y permisos.
  - Proteger rutas sensibles y recursos crÃ­ticos.
  - Agregar pruebas automatizadas para los endpoints de usuarios y roles.

- Opcional: Reportes y EstadÃ­sticas
  - Implementar endpoints para generar reportes y estadÃ­sticas.
  - Agregar filtros y parÃ¡metros para personalizar los reportes.

- Paso 18: Movimientos de stocks y Control de Inventario
  - Implementar endpoints para registrar movimientos de stocks.
  - Agregar lÃ³gica de negocio para controlar el inventario.
  - Implementar endpoints para consultar el stock disponible y los movimientos de inventario.
  - Agregar pruebas automatizadas para los endpoints de inventario.

- Paso 20: MÃ³dulo de importar/exportar datos
  - Implementar endpoints para importar y exportar datos en formato CSV o JSON.
  - Agregar validaciones y transformaciones de datos para garantizar la integridad.

- Paso 21: Seguridad y Buenas PrÃ¡cticas en ProducciÃ³n
  - Configurar Helmet y Rate Limiting para proteger la API.
  - Evitar inyecciones SQL y ataques XSS.
  - Agregar CORS con restricciones adecuadas.
